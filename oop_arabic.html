<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>البرمجة كائنية التوجه مقابل البرمجة الوظيفية</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #1a1a2e;
            line-height: 2;
            direction: rtl;
        }

        header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e0e0e0;
            padding: 40px 20px;
            text-align: center;
        }

        header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            color: #ffffff;
        }

        header p {
            font-size: 1.1em;
            color: #a0b4c8;
        }

        .container {
            max-width: 900px;
            margin: 30px auto;
            padding: 0 20px;
        }

        .section {
            background: #ffffff;
            border-radius: 12px;
            padding: 30px 35px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
            border-right: 5px solid #0f3460;
        }

        .section h2 {
            font-size: 1.5em;
            color: #0f3460;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8e8e8;
        }

        .section p {
            font-size: 1.05em;
            margin-bottom: 14px;
            text-align: justify;
        }

        .highlight {
            background-color: #f8f9ff;
            border-radius: 8px;
            padding: 15px 20px;
            margin: 15px 0;
            border-right: 4px solid #e94560;
            font-style: italic;
        }

        .quote {
            background-color: #fff8f0;
            border-radius: 8px;
            padding: 15px 20px;
            margin: 15px 0;
            border-right: 4px solid #f0a500;
        }

        footer {
            text-align: center;
            padding: 30px 20px;
            color: #666;
            font-size: 0.95em;
        }
    </style>
</head>
<body>

<header>
    <h1>البرمجة كائنية التوجه مقابل البرمجة الوظيفية</h1>
    <p>ديف فارلي - قناة Continuous Delivery</p>
</header>

<div class="container">

    <!-- المقدمة -->
    <div class="section">
        <h2>المقدمة</h2>
        <p>أحد أكثر مقاطع الفيديو نجاحًا على قناتي حتى الآن يُقارن بين البرمجة الوظيفية والبرمجة كائنية التوجه. هذا موضوع مثير للاهتمام، وبوضوح ليس بالنسبة لي فقط. لكن هناك المزيد في هذا النقاش مما ناقشناه في تلك الحلقة.</p>
        <p>هذا واحد من تلك النقاشات التي، بصراحة، تبدو غريبة بعض الشيء بالنسبة لي. موقفي ليس أنني أكره البرمجة الوظيفية وأحب البرمجة كائنية التوجه، أو العكس، بل إنني أعتبر كلًّا من هذه المنهجيات أدوات وليست أشياء نخوض حروبًا بسببها. فما هي الحجج المؤيدة والمعارضة للبرمجة كائنية التوجه والبرمجة الوظيفية؟</p>
        <p>مرحبًا، أنا ديف فارلي من قناة Continuous Delivery. مرحبًا بكم في قناتي، وإذا لم تكونوا هنا من قبل، يُرجى الاشتراك، وإذا أعجبكم المحتوى اليوم، اضغطوا على زر الإعجاب أيضًا.</p>
    </div>

    <!-- لا يوجد "الأفضل" -->
    <div class="section">
        <h2>لا يوجد "الأفضل" المطلق</h2>
        <p>بالنسبة لي، لا يوجد "البرمجة كائنية التوجه هي الأفضل" أو "البرمجة الوظيفية هي الأفضل". هناك أوقات تكون فيها البرمجة الوظيفية هي الخيار الأفضل لبعض الأشياء، وأوقات تكون فيها البرمجة كائنية التوجه هي الأفضل لأشياء أخرى.</p>
        <p>معظم الأنظمة التي أتذكر بناءها كانت تحتوي على بعض جوانب كلتا المنهجيتين، على الرغم من أنني لا أزال أعتبر نفسي في الغالب مبرمجًا كائنيَّ التوجه بالدرجة الأولى. ليس بسبب دعم اللغة، بل لأن أفكار البرمجة كائنية التوجه أو الأفكار الوظيفية كانت الأكثر منطقية في سياق الكود الذي كنا نكتبه في ذلك الوقت.</p>
        <p>كنت مبرمجًا كائنيَّ التوجه بلغة C لفترة طويلة، وبعض أكوادي بلغة C كانت تُمرِّر مؤشرات إلى دوال يمكنني استدعاؤها بشكل تعدديِّ الأشكال، مع استخدام هياكل بيانات غير قابلة للتغيير. لذا كان كود C الخاص بي كائنيَّ التوجه ووظيفيًّا في آن واحد.</p>
    </div>

    <!-- الاستقطاب في النقاش -->
    <div class="section">
        <h2>الاستقطاب في النقاش</h2>
        <p>لكن الفرق بين البرمجة كائنية التوجه والبرمجة الوظيفية هو أحد تلك النقاشات التي يبدو أنها تستقطب الناس. يمكن أن ننتهي بمحاولة تسجيل نقاط في جدال بدلًا من تسليط الضوء على الموضوع إذا لم نكن حذرين.</p>
    </div>

    <!-- لغات الأغراض العامة -->
    <div class="section">
        <h2>لغات الأغراض العامة مقابل اللغات الخاصة بالمجال</h2>
        <p>أول شيء يجب قوله قد يكون واضحًا، لكن لغات البرمجة ذات الأغراض العامة هي عامة الأغراض بمعنى أنه يمكنك كتابة أي نظام بأي لغة. لا يوجد شيء يمكنك فعله بلغة كائنية التوجه ولا يمكنك فعله بلغة وظيفية والعكس صحيح. هذا هو حقًّا ما تعنيه عبارة "عامة الأغراض".</p>
        <p>هناك فرق بين لغة عامة الأغراض ولغة خاصة بالمجال. اللغات الخاصة بالمجال لديها، بالتصميم، تركيز أضيق على مجالها المحدد. على سبيل المثال، SQL هي مثال جيد للغة خاصة بالمجال وهي ممتازة في العثور على مجموعة من السجلات ضمن مجموعة بيانات، لكنها ستكون خيارًا سيئًا إلى حدٍّ ما لكتابة لعبة Space Invaders.</p>
        <p>هذا لا يعني أن كل لغة عامة الأغراض هي دائمًا خيار جيد بنفس القدر لأي مشكلة، لكنه يعني أن أي لغة عامة الأغراض يمكن استخدامها لحل أي مشكلة في علم الحاسوب. هذه هي فكرة اكتمال تورنغ، التي تصف شمولية الحوسبة. قد يكون من السيئ كتابة نظام تشغيل بلغة Python، لكن يمكننا ذلك.</p>
        <p>لذا بينما قد يكون من الأسهل كتابة كود غير قابل للتغيير وتمرير الدوال كمعاملات في Haskell، يمكننا كتابة كود بنفس التأثير في C أو Java أو أي لغة عامة أغراض أخرى أيضًا. وبينما قد يكون من الأصعب كتابة كود ذي آثار جانبية في Clojure أو Haskell، لا يزال بإمكاننا فعل ذلك إذا حاولنا بجهد كافٍ.</p>
    </div>

    <!-- الفرق الحقيقي -->
    <div class="section">
        <h2>الفرق الحقيقي: الصياغة وليس القدرة</h2>
        <p>إذن الفرق الحقيقي بين هذه النماذج البرمجية المختلفة ليس ما تسمح لنا بفعله، بل مدى سهولة قيامنا بالأشياء التي نريد فعلها. هذا يتعلق بالصياغة أكثر من القدرة.</p>
        <p>لكن الصياغة مهمة. يمكنها أن تُغيِّر طريقة تفكيرنا في المشكلة التي نحاول حلها. اللغات المختلفة والنماذج البرمجية المختلفة تجعل بعض الأفكار أسهل في التعبير عنها. هذا كل ما في الأمر حقًّا.</p>
    </div>

    <!-- مثال Map -->
    <div class="section">
        <h2>مثال بسيط: Map</h2>
        <p>لنلقِ نظرة على مثال بسيط جدًّا. فكرة شائعة من البرمجة الوظيفية هي فكرة التعيين (mapping)، كما في map و reduce. في هذا السياق، map هي دالة من الدرجة العليا تعني "طبِّق دالة معينة على كل عنصر في مجموعة". غالبًا ما يُنظر إلى هذا على أنه أحد الطرق المفضلة لمعالجة القوائم.</p>
        <p>إحدى الطرق التي يُعتبر فيها map أفضل هي من حيث الأداء. الآن الإجابة الحقيقية عما إذا كانت عمليات map تعالج القوائم أسرع من الحلقات التكرارية هي... الأمر يعتمد. ويعتمد على أشياء كثيرة.</p>
    </div>

    <!-- التزامن والأداء -->
    <div class="section">
        <h2>التزامن والأداء</h2>
        <p>إحدى المزايا الشائعة المذكورة للبرمجة الوظيفية هي أنها تجعل التزامن أسهل. هذا صحيح. كتابة دوال نقية غير قابلة للتغيير يعني أننا نستطيع موازاتها تلقائيًّا. لكن لماذا هذه فكرة جيدة؟ الافتراض الساذج هو أن الموازاة بهذه الطريقة تعني أننا سنحصل على النتائج بشكل أسرع، لكن هذا لا يكون صحيحًا تقريبًا أبدًا إذا قمت بقياسه.</p>
        <p>المشكلة هنا هي أن التزامن جيد لكنه يُحسِّن الأداء فقط عندما لا نحتاج إلى دمج النتائج معًا مرة أخرى. بمجرد أن نحتاج إلى إعادة دمج النتائج، فإن تكاليف الأقفال والإشارات (semaphores) وإخفاقات ذاكرة التخزين المؤقت (cache misses)، وحتى الآلية الأكثر كفاءة على الإطلاق لإدارة هذا النوع من الدمج المتزامن — عمليات المقارنة والتبديل (compare and swap) — تهيمن على الأداء. عمليات المقارنة والتبديل غالبًا ما تكون أبطأ بمئات المرات من خيط واحد (single thread). على سبيل المثال، فأنت تحتاج إلى 100 خيط للحصول على نفس أداء خيط واحد، وعندها ستكون مشاكل التزامن لديك أسوأ.</p>
        <p>لذا يمكن أن تكون map رائعة لتقسيم المشاكل إلى عمليات متوازية، لكنها ستكون دائمًا أبطأ بكثير إذا كنت تحتاج إلى إعادة دمج البيانات مرة أخرى للنظر إليها.</p>
    </div>

    <!-- سهولة القراءة -->
    <div class="section">
        <h2>سهولة القراءة والبساطة</h2>
        <p>فإذا لم تحقق مكاسب في الأداء، فما هي الفوائد الأخرى؟ هل الحل أبسط أو أسهل في القراءة؟ أعتقد أن هذه مسألة ذوق. لكنني أعترف أنني لا أهتم كثيرًا حقًّا. لا أرى ميزة حقيقية في أي من التمثيلين هنا. كمبرمج من المدرسة القديمة، ربما أفضل الطبيعة الصريحة للحلقات التكرارية قليلًا، لكن هذا لا يُحدث فرقًا كبيرًا بالنسبة لي حقًّا.</p>
        <p>الطبيعة المُطوَّلة للغة Java في هذا المثال بالتأكيد لا تُظهر map في أفضل صورها هنا. نتيجة لذلك، فكرت في كتابتها بلغة Python بدلًا من ذلك. ويجب أن أُريكم هذه المفارقة الصغيرة لأنها مضحكة: لا يمكنك استدعاء print من داخل Lambda في Python، لذا ينتهي بك الأمر بفعل هذا بدلًا من ذلك، وهو بالتأكيد أسوأ من الحلقة التكرارية.</p>
    </div>

    <!-- نمذجة المشكلة -->
    <div class="section">
        <h2>نمذجة المشكلة والتصميم الموجَّه بالمجال</h2>
        <p>من الناحية التقنية أكثر، يتحدث المبرمجون الوظيفيون ومبرمجو البرمجة كائنية التوجه عن قيمة أفكار مختلفة، كلٌّ منها مختار لإبراز مزايا المنهج المفضل لديهم. عادةً ما يتحدث مبرمجو البرمجة كائنية التوجه عن قيمة نمذجة المشكلة. أنا أُقدِّر سهولة التنقل عالي المستوى في المشكلة الذي أحصل عليه من البرمجة كائنية التوجه. هذا صحيح. لكن هذه النمذجة ليست حكرًا على البرمجة كائنية التوجه فقط.</p>
        <p>هناك عرض تقديمي جيد من ماركو إمريش حول المنهج الوظيفي في التصميم الموجَّه بالمجال (Domain Driven Design) استمتعت به بشكل خاص. أعجبتني فكرة ماركو بأن المجال الأساسي للنظام يكون وظيفيًّا وأن المدخلات والمخرجات (I/O) عند الأطراف تكون دائمًا غير وظيفية، لأنها تحتوي على آثار جانبية. بعد أن أخزِّن شيئًا في ملف أو قاعدة بيانات، وهي حالة مشتركة قابلة للتغيير، أريد حقًّا أن تكون الحالة قد تغيرت.</p>
        <p>هذه رؤية مثيرة للاهتمام وبالتأكيد لها علاقة بالطريقة التي أصمم بها الأنظمة عادةً، على الرغم من أنني، كما قلت سابقًا، أعتبر منهجي أقرب إلى البرمجة كائنية التوجه منه إلى الوظيفية.</p>
    </div>

    <!-- تعريفات البرمجة كائنية التوجه -->
    <div class="section">
        <h2>تعريفات البرمجة كائنية التوجه</h2>
        <p>تعريفات البرمجة كائنية التوجه تتضمن عادةً: <strong>التجريد</strong> (Abstraction) الذي يسمح لنا بإخفاء التفاصيل غير الضرورية، و<strong>الوراثة</strong> (Inheritance) أي تعريف نوع من الأشياء بدلالة نوع آخر، و<strong>تعدد الأشكال</strong> (Polymorphism) أي القدرة على الوصول إلى أشياء من أنواع مختلفة من خلال نفس الواجهة، و<strong>التغليف</strong> (Encapsulation) الذي يسمح لنا بإخفاء التفاصيل غير المهمة.</p>
        <p>أعتقد أن معظم المبرمجين الوظيفيين سيوافقون على أن كل هذه أشياء جيدة، ربما باستثناء الوراثة. في الواقع، كل هذه مبادئ تدعم أيضًا البرمجة الوظيفية. الأمر فقط أننا نصف هذه الأشياء بمصطلحات مختلفة نوعًا ما.</p>
        <p>المبرمجون الوظيفيون يتحدثون عن البرمجة التصريحية (Declarative Programming)، وهي في الحقيقة شكل من أشكال التجريد وإخفاء المعلومات، واستخدام الأنواع (Types)، الذي يعتمد على فكرة تعدد الأشكال.</p>
    </div>

    <!-- الوراثة -->
    <div class="section">
        <h2>الوراثة: سلاح ذو حدين</h2>
        <p>لكن الوراثة أمر معقد، لأنه بينما من الواضح أن لها بعض الفوائد القوية، فقد أُسيء استخدامها أيضًا في كثير من الأحيان ويمكن أن يكون لها بعض العيوب الخطيرة. إذا أنشأت نافذة جديدة أو زرًّا على شاشتك، فمن خلال الوراثة يمكنك تغيير حجمه أو النقر عليه. البرمجة كائنية التوجه كانت الخطوة التقنية التي حررت حقًّا مشاركة الكود، وليس من المفاجئ أن البرمجة كائنية التوجه وواجهة المستخدم الرسومية (GUI) جاءتا من نفس المكان — مركز أبحاث زيروكس بارك (Xerox PARC). واجهة المستخدم الرسومية هي في العمق فكرة مستوحاة من البرمجة كائنية التوجه.</p>
        <p>عندما يسخر المبرمجون غير الكائنيين من البرمجة كائنية التوجه، فإنهم غالبًا ما يسخرون بشكل أساسي من الوراثة. ذلك لأنه يمكنك صنع فوضى عارمة بالوراثة، إلى حد أن الأشخاص الذين يفضلون إجابات ثنائية بسيطة سيقولون في كثير من الأحيان "الوراثة سيئة". بالطبع الوراثة ليست سيئة، لكن الوراثة السيئة هي بالتأكيد سيئة.</p>
        <p>الخطأ الكبير في الوراثة، وأقول على الأرجح في البرمجة عمومًا، هو عدم نمذجة المشكلة التي تحاول حلها بشكل جيد بما فيه الكفاية. البرمجة التكتيكية غالبًا ما تكون عرضة لأن تكون حلولًا تكتيكية رديئة.</p>
        <div class="highlight">
            <p>على سبيل المثال، في Java، المجموعة (Set) ترث من المتجه (Vector)، والخصائص (Properties) ترث من جداول التجزئة (Hash Tables). هذه حلول تكتيكية رديئة، لأن المجموعة ليست متجهًا، والخصائص ليست جداول تجزئة. كان هذا خيارًا كسولًا لأنه جعل تنفيذ المجموعات والخصائص أسهل، لكنه في الحقيقة هراء.</p>
        </div>
        <p>المجموعة ليست متجهًا، وهذا يؤدي إلى جميع أنواع الميزات في المجموعات في Java التي لا معنى لها على الإطلاق. ماذا يعني "فهرس" (index of) مُدخَل بالنسبة لمجموعة؟ أو لماذا أرغب في إعادة تجزئة خصائصي؟</p>
        <p>هذا ليس خطأ الوراثة في حد ذاتها. هذا مجرد خيار تصميمي تكتيكي سيئ. ويمكننا بالتأكيد اتخاذ خيارات تصميمية سيئة في أي لغة، حتى اللغات الوظيفية.</p>
    </div>

    <!-- القرارات الرئيسية في البرمجيات -->
    <div class="section">
        <h2>القرارات الرئيسية في البرمجيات</h2>
        <p>أعتقد أن القرارات الرئيسية في البرمجيات تقع خارج التفاصيل التقنية للغات الفردية إلى حد كبير، أو نماذج لغات البرمجة في هذا الشأن. إذا أردتم رؤية ما أعنيه، ألقوا نظرة على دورتي التدريبية "برمجيات أفضل بشكل أسرع" (Better Software Faster). إنها تصف ما يتطلبه بناء برمجيات عالية الجودة ولماذا يهم ذلك. هناك رابط في الوصف أدناه.</p>
    </div>

    <!-- ادعاءات البرمجة الوظيفية -->
    <div class="section">
        <h2>ادعاءات البرمجة الوظيفية</h2>
        <p>في عرض ماركو التقديمي، يقتبس عن المبرمجين الوظيفيين قولهم: "البرمجة الوظيفية رائعة لأنها تحتوي على هياكل بيانات غير قابلة للتغيير، ونموذج برمجة عديم الحالة، ودوال نقية، وبدون حلقات تكرارية. هذه الأشياء تجعل من السهل التفكير في الكود الخاص بك"، كما يقولون.</p>
        <div class="quote">
            <p>حسنًا، في معظم لغات البرمجة كائنية التوجه، يمكنني بسهولة إنشاء هياكل بيانات غير قابلة للتغيير، وبرمجة كود عديم الحالة، وإنشاء دوال نقية، وتجنب الحلقات التكرارية إذا اخترت ذلك، حتى قبل اختيار استخدام الميزات الوظيفية التي أُضيفت إلى معظم لغات البرمجة كائنية التوجه الحديثة هذه الأيام.</p>
        </div>
    </div>

    <!-- القيمة الحقيقية للبرمجة الوظيفية -->
    <div class="section">
        <h2>القيمة الحقيقية للمنهج الوظيفي</h2>
        <p>القيمة الحقيقية في المنهج الأكثر وظيفية في البرمجة، كما أراها، تكمن حقًّا في ثلاث مجالات: <strong>معاملة الدوال كمتغيرات</strong>، و<strong>عدم القابلية للتغيير</strong>، و<strong>البرمجة التصريحية</strong>.</p>

        <h3 style="color: #0f3460; margin: 20px 0 10px;">الدوال كمتغيرات</h3>
        <p>الدوال كمتغيرات هي خطوة مهمة. مرة أخرى، لا تحتاج إلى لغة وظيفية لفعل هذا. اعتدت على عمل نسخ من هذا في لغة التجميع (Assembler) وC وC++ وJava وPython. لكن وجود دعم مباشر من اللغة بالتأكيد يجعل استخدامها أجمل. هذا يسمح لنا بتمرير دالة كمعامل إلى دالة أخرى، والتي يمكنها بعد ذلك استدعاء تلك الدالة.</p>
        <p>إذا صادفت في أي وقت قطعتي كود متشابهتين جدًّا لكن بينهما اختلاف طفيف، مثل هذا، فإن هذه القدرة على تمرير دالة كمعامل هي أداة رائعة حقًّا لتبسيط الكود وتعميمه. هذه أيضًا هي الفكرة وراء أشياء مثل معالجات الأحداث (Event Handlers). أوه، انتظر، أليست هذه فكرة من البرمجة كائنية التوجه؟</p>

        <h3 style="color: #0f3460; margin: 20px 0 10px;">عدم القابلية للتغيير</h3>
        <p>عدم القابلية للتغيير (Immutability) أداة مهمة، لكنها ليست الأداة الوحيدة أبدًا. في مرحلة ما تريد تغيير الأشياء، لأنه خلاف ذلك ما الغرض من الكود الخاص بك؟ هذا أحد الأسباب التي جعلتني أحب نقطة ماركو بأن المدخلات والمخرجات (I/O) عند أطراف نظامك لها دائمًا آثار جانبية، لأنها لو لم تكن كذلك، فإن الكود الخاص بك لا يفعل شيئًا.</p>
        <p>أوافق على أن تقليل الآثار الجانبية في الكود يمكن أن يجعل الأمور أسهل في الفهم، لكنها أيضًا ليست الإجابة الكاملة أبدًا، على الأقل بالمعنى الأنقى لعدم وجود حالة قابلة للتغيير. على مستوى الأنظمة الكاملة، هناك حالات نادرة جدًّا تكون فيها الأنظمة عديمة الحالة بشكل حقيقي ذات معنى، وذلك فقط في سياقات ضيقة جدًّا حيث يعمل الكود كنوع من الأنابيب التي تُغيِّر البيانات بطريقة ما.</p>
        <p>هذه الفكرة ذات قيمة كبيرة كجزء من نظام، كخطوة تبسيطية، لكن في الأنظمة الكاملة، هناك دائمًا حالة تتغير في مكان ما. لذا فإن فكرة الأنظمة عديمة الحالة ليست مطلقة أبدًا. الأمر يتعلق أكثر بالمكان الذي تتعامل فيه مع تغييرات الحالة بدلًا من القضاء عليها جميعًا.</p>
        <p>تقليل الآثار الجانبية أمر رائع في المكان المناسب، وكان، بأثر رجعي، جانبًا مهمًّا من منهجي الشخصي في التصميم كائني التوجه لفترة طويلة جدًّا.</p>
        <div class="quote">
            <p>كما قال لي مايكل فيذرز (Michael Feathers) في محادثتنا قبل بضعة أشهر: "البرمجة كائنية التوجه تبدو كثيرًا مثل البرمجة الوظيفية عندما تُنفَّذ بالشكل الصحيح."</p>
        </div>
    </div>

    <!-- الآثار الجانبية ضرورية أحيانًا -->
    <div class="section">
        <h2>الآثار الجانبية ضرورية أحيانًا</h2>
        <p>لكن سواء كنت تطوِّر بأسلوب كائني التوجه أو وظيفي، هناك أوقات تريد فيها آثارًا جانبية. لقد تحدثنا بالفعل عن الأوقات الواضحة عندما تقوم بعمليات الإدخال والإخراج من أي نوع. إذا كنت تريد الكتابة إلى ملف، فإن الحالة التي يكون عليها الملف مهمة. بالتأكيد، يمكنك استنساخ لقطة غير قابلة للتغيير من صورة ذلك الملف، لكن فورًا عندما تفعل ذلك، تكون على الأقل من المحتمل قديمة، لأن الملف الحقيقي على القرص مُشارَك. ربما قام شخص آخر بتغيير الملف، أو حذفه نظام التشغيل بينما كنت في طور التعامل مع نسختك. الآن لقطتك غير القابلة للتغيير من الملف خاطئة.</p>
        <p>التغيير في الملف أو في قاعدة البيانات هو دائمًا أثر جانبي. لسبب آخر أيضًا: إنه أثر جانبي للعمل مع حواسيب تنسى الأشياء عندما نُطفئها. إذا غيَّرت الرصيد في حسابي، فإن حقيقة أنني أحتاج إلى تخزين ذلك التغيير في مكان ما ليست هدفي. التغيير في الرصيد هو هدفي، لذا فإن التخزين هو مجرد أثر جانبي.</p>
        <p>لغات البرمجة الوظيفية بالطبع تدعم هذا النوع من الأشياء، وبعضها يدعم أفكارًا مثل المونادات (Monads) التي تسمح لنا بكسر قاعدة "الدوال النقية" في البرمجة الوظيفية بإضافة آثار جانبية. لكنني أقول إن هذه مجرد حالة خاصة من فكرة أكثر عمومية.</p>
    </div>

    <!-- الأنظمة التفاعلية -->
    <div class="section">
        <h2>الأنظمة التفاعلية القائمة على الرسائل</h2>
        <p>أحد مناهجي المعمارية المفضلة هو بناء أنظمة تفاعلية قائمة على الرسائل. هذه الأشياء تشبه فاعلين (Actors) ذوي حالة يتواصلون فقط عبر رسائل غير متزامنة. أحد الأسباب التي تجعلني أحب هذه الأنظمة كثيرًا هو أنها تسمح لي بفصل التعقيد العَرَضي (Accidental Complexity) عن التعقيد الجوهري (Essential Complexity) في نظامي.</p>
        <p>لنتخيل أن لدي حسابًا مصرفيًّا من نوع ما وأريد إضافة رصيد إليه. في منهجي المفضل القائم على الفاعلين، قد أرسل رسالة إيداع بالقيمة التي أريد إضافتها. ستدير بنيتي التحتية عمليات الإدخال والإخراج — ستحفظ الرسالة في طريقها إلى خدمتي. وفقط إذا تم تخزين الرسالة بأمان أو نسخها عنقوديًّا أو أيًّا كان، ستوجهها بعد ذلك إلى خدمتي. عند هذه النقطة، ستُحدِّث خدمتي قيمة الحساب الذي تحتفظ به لإنشاء رصيد إجمالي جديد.</p>
        <p>هل هذه حالة قابلة للتغيير أم لا؟ هل هذه برمجة كائنية التوجه أم لا؟ أقول إن هذه طريقة تفكير وعمل كائنية التوجه بامتياز. فاعليّ (Actors) يجسدون حالة غنية لنماذج مجال المشكلة التي أحلها. لكن هنا آثاري الجانبية — التخزين — معزولة، ربما أكثر عزلة مما هي عليه في بعض الأنظمة الوظيفية. والتغيير في الحالة، وهو تغيير مهم يجب أن يُمثَّل في مكان ما، مُعبَّر عنه بوضوح وسهل الفهم. ولا يمكن أن يحدث بدون حدوث الآثار الجانبية المهمة أولًا.</p>
        <p>في النهاية، لا أريد أن تختفي مائة يورو الخاصة بي، وأريد أن أعرف أن مجموعي دقيق حتى بعد عطل أو إعادة تشغيل.</p>
        <p>إذا أردت معرفة رصيد حسابي، يمكنني الاستعلام عن هذه النسخة ذات الحالة. لكن يمكنني أيضًا التخلص من هذه النسخة وإعادة إنشائها بنفس الحالة تمامًا كما كانت من قبل عن طريق إعادة تشغيل الرسائل التي خزَّنتها سابقًا.</p>
        <p>فمرة أخرى، هل هذه الحالة هنا قابلة للتغيير أم لا؟ في الحقيقة، أعتقد أنها نوعًا ما كلاهما.</p>
    </div>

    <!-- الخط الفاصل ضبابي -->
    <div class="section">
        <h2>الخط الفاصل ضبابي</h2>
        <p>نقطتي هنا ليست الإشادة بالأنظمة التفاعلية — حسنًا، ربما قليلًا — بل الإشارة إلى أن الخط الفاصل بين البرمجة كائنية التوجه والبرمجة الوظيفية، وربما حتى الفاعلين (Actors)، كله أكثر ضبابية مما توحي به حروب الثقافة أحيانًا.</p>
        <p>نعم، من المعقول تقليل الآثار الجانبية في الكود الخاص بك، مهما كانت طبيعة الكود. لكن هل هناك حقًّا فرق كبير بين أن يكون لديك دالة تأخذ معاملين، أحدهما مُقدَّم من دالة أخرى تحدد قيمته، وكائن بمتغير عضو خاص يُستخدم بدلًا من المتغير المُقدَّم من الدالة؟</p>
        <p>بالتأكيد، كود البرمجة كائنية التوجه هنا أكثر إطالة، لكن هذا سؤال مختلف. حقًّا كل ما يحدث هنا هو كيف نقرر تمثيل تسلسل استدعاءات الدوال.</p>
        <p>يمكننا أن نتناقش حول أيهما أسهل في القراءة، وهناك حجج على كلا الجانبين. لكنني أعتقد أنه إذا كنا نُحسِّن فقط لتقليل الكتابة، فنحن بالفعل ننظر في المكان الخطأ. ليس هناك الكثير من الكتابة في برامج لغة التجميع في النهاية. التحسين من أجل التفكير أهم بكثير.</p>
    </div>

    <!-- البرمجة التصريحية -->
    <div class="section">
        <h2>البرمجة التصريحية مقابل الأمرية</h2>
        <p>نقطتي هنا ليست الحط من قيمة البرمجة الوظيفية. نقطتي هي أنني أعتقد أن النقاش يجب أن يكون أكثر دقة بكثير من "البرمجة كائنية التوجه سيئة، البرمجة الوظيفية جيدة"، أو العكس.</p>
        <p>هناك بالتأكيد أوقات تكون فيها البرمجة الوظيفية أكثر إيجازًا، والإيجاز يمكن أن يكون جيدًا. لكنه يمكن أن يكون سيئًا أيضًا، في النهاية اعتمادًا على مدى سهولة قراءة الكود وفهمه.</p>
        <p>آخر الأفكار التي يستشهد بها المبرمجون الوظيفيون غالبًا باعتبارها القيمة الحقيقية للبرمجة الوظيفية هي ميزة البرمجة التصريحية (Declarative) على البرمجة الأمرية (Imperative). تحدثت عن هذا من قبل. هناك بالتأكيد مزايا كبيرة للتعبير عن بعض الأفكار تصريحيًّا.</p>
        <p>منهجي في التطوير القائم على الاختبارات (Test Driven Development) هو أن أهدف دائمًا إلى التصريح في اختباري بما أريد أن يفعله النظام، دون محاولة اختبار كيف يفعله أو قول كيف يفعله. هذا يعني أن اختباراتي أكثر متانة تجاه التغيير من الاختبارات التي تحاول التأكيد على تفاصيل التنفيذ في الكود. هذه نفس فكرة البرمجة التصريحية.</p>
        <p>إذا استطعنا التعبير بوضوح عن النتيجة التي نود تحقيقها دون القلق بشأن كيفية تحقيق النتيجة، فهذا رائع. أرى الكثير من الأمثلة على هذا في أمثلة الكود الوظيفي. لكن بصراحة، هذا أقل وضوحًا في الكود الحقيقي للناس، بقدر ما يمكنني رؤيته.</p>
        <p>لأكون منصفًا، تعرُّضي لقراءة أكواد وظيفية لأشخاص آخرين محدود نوعًا ما. لا أقرأ الكثير منها. لذا قد يكون هذا بسبب حدود تجربتي. لكن إذا كان الأمر كذلك، إذا كانت مستويات التجريد التي تمنحنا إياها اللغات الوظيفية مفيدة حقًّا بالقدر الذي يخبرنا به المبرمجون الوظيفيون، فألا يجب أن تُثبت المشاريع الوظيفية أنها أسرع بكثير في التطوير وتُنتج أخطاء أقل من المشاريع غير الوظيفية؟</p>
    </div>

    <!-- الأدلة والأبحاث -->
    <div class="section">
        <h2>الأدلة والأبحاث</h2>
        <p>هذا هو الادعاء الذي يطرحه المبرمجون الوظيفيون أحيانًا، لكنني بحثت ولم أجد الكثير من الأدلة لدعم هذا الادعاء. البرمجة الوظيفية تبدو أنها تُنتج أخطاء أقل، لكن الأبحاث التي قرأتها تقول إن هذا عند مستوى أو قريب من مستوى الضجيج الإحصائي، مما ينتج عنه حوالي 1% أقل في التزامات إصلاح الأخطاء (bug fix commits) مقارنة باللغات الأمرية، عند القياس بمقارنة نسبة التزامات الأشياء الجديدة مقابل التزامات إصلاح الأخطاء.</p>
        <p>لوضع هذا في سياقه، البيانات الخاصة باختبار الوحدات (Unit Testing) تقول إنك تحصل على حوالي 58% انخفاض في عيوب الإنتاج بشكل عام، وإن كان يُقاس بطريقة مختلفة تمامًا. لذا قد لا يكون من العدل أن أُجري هذه المقارنة. لكن الفرق، إن وُجد، في جودة الكود الذي تنتجه البرمجة الوظيفية مقابل لغات البرمجة كائنية التوجه يبدو ضئيلًا جدًّا.</p>
    </div>

    <!-- الخلاصة -->
    <div class="section">
        <h2>الخلاصة</h2>
        <p>أعتقد أن كلًّا من البرمجة الوظيفية والبرمجة كائنية التوجه أدوات قيِّمة. لكنني أعتقد أيضًا أن هناك بعض الادعاءات المبالغ فيها للبرمجة الوظيفية بشكل خاص، والتي بالنسبة لي على الأقل لا تبدو أنها تصمد أمام التدقيق.</p>
        <div class="highlight">
            <p>استنتاجي هو أنه من المجدي فهم كلٍّ من البرمجة الوظيفية والبرمجة كائنية التوجه. فكرة أن البرمجة الوظيفية هي خطوة تتجاوز البرمجة كائنية التوجه في تطور لغات البرمجة تبدو مجرد تفسير خاطئ تمامًا للتاريخ ولما يحدث في الواقع.</p>
        </div>
        <p>البرمجة كائنية التوجه والبرمجة الوظيفية كلتاهما أدوات قيِّمة لبناء أنظمة معقدة. استخدمهما في السياق المناسب، وكل منهما سيساعدك على بناء أنظمة أفضل. لكن لا أحد منهما هو العامل الحاسم.</p>
        <p>شكرًا جزيلًا لكم على المشاهدة.</p>
    </div>

</div>

<footer>
    <p>ترجمة الحديث الأصلي لـ ديف فارلي - قناة Continuous Delivery</p>
</footer>

</body>
</html>
